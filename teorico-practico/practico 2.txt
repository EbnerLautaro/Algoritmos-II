# Ejercicio 2a
proc intercalar_cada (in/out a:array [1..2^n] of int, in i :nat)
  
  var tam, lft, rgt, mid : int
  tam := 2^(i + 1)            # fija el tamanio que a ordenar
  lft := 1                    # en 1 porque es el principio
  rgt := tam                  # en tam porque ordenamos hasta ese rango
  mid := (lft + rgt) / 2      # mitad

  # PRE los elementos con intervalo menor a i tienen que estar ordenados

  while rgt <= 2^n do         # se fija que no se vaya a la verga

    merge(a, lft, mid, rgt)   # intercalamos los primeros elementos
    
    # siguiente intervalo 
    lft := rgt + 1            
    rgt := rgt + tam
    mid := (lft + rgt) / 2

  od
endproc


# Ejercicio 2b
proc intercalar_cada (in/out a:array [1..2^n] of int, in i :nat)

    var tam, lft, rgt, mid : int
    for i:=0 to n-1 do
        tam := 2^(i + 1)            # fija el tamanio que a ordenar
        lft := 1                    # en 1 porque es el principio
        rgt := tam                  # en tam porque ordenamos hasta ese rango
        mid := (lft + rgt) / 2      # mitad
        # PRE los elementos con intervalo menor a i tienen que estar ordenados
        while rgt <= 2^n do         # se fija que no se vaya a la verga

            merge(a, lft, mid, rgt)   # intercalamos los primeros elementos
            
            # siguiente intervalo 
            lft := rgt + 1            
            rgt := rgt + tam
            mid := (lft + rgt) / 2

        od
    od
endproc

#Ejercicio 3a
[7, 1, 10, 3, 4, 9, 5]      # partition (a, 1, 7, pivot) -> devuelve 5
 . 
[7, 1, 10, 3, 4, 9, 5]      
 .              
[7, 1, 3, 4, 5, 9, 10]
             :
[5, 1, 3, 4, 7, 9, 10]      # quick_sort_rec(a,1,4)
 .           :
[5, 1, 3, 4, 7, 9, 10]      # partition (a, 1, 4, pivot) -> devuelve 4
 .           :
[5, 1, 3, 4, 7, 9, 10]
          :  :
[4, 1, 3, 5, 7, 9, 10]      # quick_sort_rec(a,1,3)
 .        :  :
[4, 1, 3, 5, 7, 9, 10]      # partition (a, 1, 3, pivot) -> devuelve 2
       :  :  :
[3, 1, 4, 5, 7, 9, 10]
       :  :  :
[3, 1, 4, 5, 7, 9, 10]
 \  :  :  :  :
[1, 3, 4, 5, 7, 9, 10]      # no hace esto porque sale del if quick_sort_rec(a,1,1), hace # quick_sort_rec(a,6,7)
 :  :  :  :  :   
[1, 3, 4, 5, 7, 9, 10]      # partition (a, 6, 6, pivot) -> devuelve 7
 :  :  :  :  :  :  \
[1, 3, 4, 5, 7, 9, 10]      # no hace esto porque sale del if quick_sort_rec(a,6,6)
 :  :  :  :  :  :  :
[1, 3, 4, 5, 7, 9, 10]      # Fin






proc partition (in/out a:array [1..n] of int, in lft,rgt: nat, out pivot: nat)
	var mid, nmid, nlft, nrgt: int
	mid := (rgt+lft)/2
	num_mid := a[mid]
	num_rgt := a[rgt]
	num_lft := a[lft]

	ppiv = intermedio(num_lft, num_mid, num_rgt)

	var i,j: nat
	i := lft
	j := rgt

	while i<=j do
		if a[i] <= a[ppiv] then
			i := i+1

		else 

			if a[j] > a[ppiv] then
				j := j-1
			else 
				if a[j] < a[ppiv] or a[i] > a[ppiv] then
					swap(a,i,j) 
				fi
			fi
		fi
	od
	swap(a,j,ppvi)
	ppiv := j
end proc

fun intermedio(a,b,c: int) ret r: int

	x :=  max(a,b,c)
	y :=  min(a,b,c)
	if ~(a=x) or ~(a=y) then 
		r := a
	else 
		if ~(b=x) or ~(b=y) then 
			r := b
		else 
			r := c
		fi
	fi
end fun







proc quicksort

	quick_sort_rec(a,lft,pivot_izq-1)		
	quick_sort_rec(a, pivot_izq+1, pivot_der-1)
	quick_sort_rec(a, pivot_der+1, rgt)


